---
title: "Advanced trajectory usage"
author: "Bart Smeets, IÃ±aki Ucar"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Advanced trajectory usage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

When a generator creates an arrival is couples the arrival to a trajectory. A trajectory can be defined as a interlinkage of activities which together form the trajectory. Once an arrival is coupled to the trajectory it will (in general) start processing the activities in the trajectory in the specified order. Consider the following:

```{r}
library(simmer)

patient_traj<-
  create_trajectory(name = "patient_trajectory") %>%
  seize(resource = "doctor", amount = 1) %>%
  timeout(3) %>%
  release(resource = "doctor", amount = 1)
  
```

Here we create a trajectory where a patient _seizes_ a doctor for 3 minutes and then _releases_ him again.

This is a very straightforward example, however, most of the trajectory related function allow for more advanced usage. The different functions are introduced below.

## set_attribute

The `set_attribute(trajectory, key, value)` function set the `value` of attribute `key`. Be aware that `value` can only be numeric.

```{r}
patient_traj<-
  create_trajectory(name = "patient_trajectory") %>%
  set_attribute("my_key", 123) %>%
  timeout(5) %>%
  set_attribute("my_key", 456)

env<-
  simmer() %>%
  add_generator("patient", patient_traj, at(0), mon = 2) %>%
  run()

get_mon_attributes(env)
  
```

Above, a trajectory which _only_ sets attribute `my_key` to value `123` is launched by the generator once at time 0 (check `?at`). Using `get_mon_attribute` we can look a the evolution of the value of `my_key`.

If you want to set an attribute that depends on another attribute, or on the current value of the attribute to be set, this is also possible. If, insted of a numeric value, you supply a function with 1 parameter, the current set of attributes is passed as a list to the function. Whatever your function supplies is set as the value of the specified attribute key. If supply a function without a parameter the function is simply evaluated (for each entity) and the returned value used. This means, that if you supply a function to the `value` parameter it has to be in the form of either `function(){}` or `function(attrs){}`. Below you can see an example of this in practice.

```{r}
patient_traj<-
  create_trajectory(name = "patient_trajectory") %>%
  set_attribute("my_key", 123) %>%
  timeout(5) %>%
  set_attribute("my_key", function(attrs) attrs[["my_key"]] + 1) %>%
  timeout(5) %>%
  set_attribute("dependent_key", function(attrs) ifelse(attrs[["my_key"]]<=123, 1, 0)) %>%
  timeout(5) %>%
  set_attribute("independent_key", function() runif(1))

env<-
  simmer() %>%
  add_generator("patient", patient_traj, at(0), mon = 2) %>%
  run()

get_mon_attributes(env)
  
```

## seize & release

The `seize(trajectory, resource, amount)` function seizes a specified `amount` of resources of type `resource`. Conversely, the `release(trajectory, resource, amount)` function releases a specified `amount` of resource of type `resource`.  Be aware that in order to use these function in relation to a specific resource type you first have to create the resource type in your definition of the simulation environment (check `?add_resource`). 

Consider the following example:


```{r}
patient_traj<-
  create_trajectory(name = "patient_trajectory") %>%
  seize(resource = "doctor", amount = 1) %>%
  timeout(3) %>%
  release(resource = "doctor", amount = 1)

env<-
  simmer() %>%
  add_resource("doctor", capacity=1, mon = 1) %>%
  add_generator("patient", patient_traj, at(0)) %>%
  run()

get_mon_resources(env)
```

Hence the `mon=1` argument (=default) to the `add_resource` which makes the simulation environment monitor resource usage. Using the `get_mon_resources(env)` function you can get access to the log of resource usage evolution.

There are situations where you want to let the amount of resources seized/released be dependent on a specific function or on a previously set attribute. To achieve this you, instead of a numeric value, pass a funciton in the form of either `function(){}` or `function(attrs){}` to the `amount` parameter. If going for the latter, the current state of the entity's attributes will be passed to `attrs` as a list which you can inspect. This allows for the following:

```{r}
patient_traj<-
  create_trajectory(name = "patient_trajectory") %>%
  set_attribute("health", function() sample(20:80, 1)) %>%
  set_attribute("docs_to_seize", function(attrs) ifelse(attrs[["health"]]<50, 1, 2)) %>%
  seize("doctor", function(attrs) attrs[["docs_to_seize"]]) %>%
  timeout(3) %>%
  release("doctor", function(attrs) attrs[["docs_to_seize"]])

env<-
  simmer() %>%
  add_resource("doctor", capacity=2, mon = 1) %>%
  add_generator("patient", patient_traj, at(0), mon=2) %>%
  run()

get_mon_resources(env)
get_mon_attributes(env)

```

## timeout

At it simplest, the `timeout(trajectory, task)` function times out (delays) the entity's trajectory with x time units. Consider the following minimal example where we simply supply a static value to the timeout's `task` parameter.

```{r}
patient_traj<-
  create_trajectory(name = "patient_trajectory") %>%
  timeout(3)

env<-
  simmer() %>%
  add_resource("doctor", capacity=2, mon = 1) %>%
  add_generator("patient", patient_traj, at(0), mon=2) %>%
  run()

get_mon_arrivals(env)

```

Often however you want a timeout to be dependent on a distribution of for example an earlier set attribute. This is achieved by passing a function in to form of either `function(){}` or `function(attrs){}` to the `task` parameter. In the following example this functionality is demonstrated:

```{r}
patient_traj<-
  create_trajectory(name = "patient_trajectory") %>%
  set_attribute("health", function() sample(20:80, 1)) %>%
  # function based timeout
  timeout(function() rpois(1, 10)) %>%
  # attribute dependent timeout
  timeout(function(attrs) (100 - attrs[["health"]]) * 2)

env<-
  simmer() %>%
  add_generator("patient", patient_traj, at(0), mon=2) %>%
  run()

get_mon_arrivals(env)
get_mon_attributes(env)

```

Be aware that if you want the `timeout`'s `task` parameter to be evaluated dynamically you should supply a callable function. For example in `timeout(function() rpois(1, 10))`, `rpois(1, 10)` will be evaluated every time the timeout activity is executes. If however, you supply it in the form of `timeout(rpois(1, 10))` it will only be evaluated at initalization and will remain static after that.


## branch

## rollback

The `rollback(trajectory, amount, times, check)` function allows one to rollback the trajectory with `amount` number of steps.

Consider the following were a string is printed in the timeout function. After the first run, the trajectory is rolled back 3 times.

```{r}
t0<-create_trajectory() %>%
  timeout(function(){
    print("Hello!")
    0}) %>%
  rollback(amount=1, times=3)


simmer() %>%
  add_generator("hello_sayer", t0, at(0)) %>% 
  run()

```

The `rollback` function also allows for a `check` parameter. You can pass a callable object (function) to this parameter. If this function returns `TRUE` it will `rollback` the trajectory with `amount` steps. Consider the following example:

```{r}
t0<-create_trajectory() %>%
  set_attribute("happiness", 0) %>%
  timeout(function(attrs){
    cat(">> Happiness level is at: ", attrs[["happiness"]], " -- ")
    cat(ifelse(attrs[["happiness"]]<25,"PETE: I'm feeling crappy...",
           ifelse(attrs[["happiness"]]<50,"PETE: Feelin' a bit moody",
                  ifelse(attrs[["happiness"]]<75,"PETE: Just had a good espresso",
                         "PETE: Let's do this! (and stop this loop...)")))
    , "\n")
    return(0) # in other words; this is a dummy timeout
  }) %>%
  set_attribute("happiness", function(attrs) attrs[["happiness"]] + 25) %>%
  rollback(amount=2, check=function(attrs) attrs[["happiness"]] < 100)


simmer() %>%
  add_generator("mood_swinger", t0, at(0)) %>% 
  run()

```



## Bringing it all together